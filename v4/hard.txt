{"prompt":"Hard 01 (procedures + lists): This procedure should return the last element of numbers. What is the bug?","code":"PROCEDURE getLast(numbers) {\n  RETURN(numbers[LENGTH(numbers) + 1])\n}\nvalues ← [3, 5, 7]\nresult ← getLast(values)\nDISPLAY(result)","choices":["It uses LENGTH(numbers) + 1, which refers to an index past the end of the list","It should call LENGTH(values) inside the procedure instead of LENGTH(numbers)","The RETURN statement must be placed after a loop that iterates through numbers","The list values must contain at least 10 elements for the LENGTH procedure to work"],"correctIndex":0}
{"prompt":"Hard 02 (procedures + lists): addToEnd is supposed to APPEND value to the end of list. What is the bug?","code":"PROCEDURE addToEnd(list, value) {\n  INSERT(list, LENGTH(list), value)\n}\nnums ← [1, 2, 3]\naddToEnd(nums, 4)\nDISPLAY(nums)","choices":["INSERT at LENGTH(list) places the value before the last element instead of after it","INSERT should only be used when the list is completely empty or uninitialized","The procedure must explicitly RETURN the list for any changes to persist","The value parameter should be added using the REMOVE command, not INSERT"],"correctIndex":0}
{"prompt":"Hard 03 (procedures + lists): This procedure should remove the first item from list. What is the bug?","code":"PROCEDURE removeFirst(list) {\n  REMOVE(list, 0)\n}\nitems ← [\"a\", \"b\", \"c\"]\nremoveFirst(items)\nDISPLAY(items[1])","choices":["Index 0 is invalid in AP CSP lists because they use 1-based indexing","It should use the INSERT command instead of REMOVE to handle the first element","The input items must be a list of numeric values rather than string values","The procedure should RETURN the modified list instead of changing it in place"],"correctIndex":0}
{"prompt":"Hard 04 (procedures + lists): doubleAll is meant to change nums so every element is doubled. Why doesn’t it work?","code":"PROCEDURE doubleAll(numbers) {\n  FOR EACH value IN numbers {\n    value ← value * 2\n  }\n}\nnums ← [1, 2, 3]\ndoubleAll(nums)\nDISPLAY(nums[1])","choices":["Reassigning the loop variable value does not update the actual element stored in numbers","The FOR EACH loop must be placed outside the PROCEDURE block to function","The list numbers must be initialized inside doubleAll, not passed as a parameter","The FOR EACH loop can only be used with lists of strings, not numbers"],"correctIndex":0}
{"prompt":"Hard 05 (procedures + lists): sumList is supposed to return the sum of the list. What is the bug?","code":"PROCEDURE sumList(numbers) {\n  total ← 0\n  FOR EACH num IN numbers {\n    total ← total + num\n  }\n}\nvalues ← [2, 4, 6]\nresult ← sumList(values)\nDISPLAY(result)","choices":["The procedure never RETURNS total, so the variable result receives no value","The variable total should be declared as a list type, not a numeric type","FOR EACH loops must not be used inside PROCEDURE definitions in this context","The sumList procedure should be called before the list values is created"],"correctIndex":0}
{"prompt":"Hard 06 (procedures + lists): average is supposed to compute the mean of the list. What loop bug prevents it from working?","code":"PROCEDURE average(numbers) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(numbers)) {\n    total ← total + numbers[index]\n  }\n  RETURN(total / LENGTH(numbers))\n}\nvalues ← [5, 7, 9]\nDISPLAY(average(values))","choices":["index is never updated inside the loop, creating an infinite loop where the condition never checks out","The loop condition must be index ≥ LENGTH(numbers) instead of index > LENGTH(numbers)","The total variable should start at 1 to avoid a potential division by zero error","The RETURN statement must appear before the loop to provide an initial value"],"correctIndex":0}
{"prompt":"Hard 07 (procedures + lists): This procedure must return the first number greater than limit. What bug can skip valid answers?","code":"PROCEDURE findFirstGreater(numbers, limit) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(numbers)) {\n    IF (numbers[index] > limit) {\n      RETURN(numbers[index])\n    }\n    index ← index + 2\n  }\n  RETURN(-1)\n}\nvalues ← [3, 4, 5, 6]\nresult ← findFirstGreater(values, 4)\nDISPLAY(result)","choices":["index increases by 2, causing the loop to skip every other element in the list","The IF statement should test numbers[index] ≥ limit instead of > limit","The final RETURN statement must be placed inside the loop instead of after it","The list numbers must be sorted in ascending order for this logic to work"],"correctIndex":0}
{"prompt":"Hard 08 (procedures + lists): appendTwice is meant to add value to list twice. What is the bug in the call?","code":"PROCEDURE appendTwice(list, value) {\n  APPEND(list, value)\n  APPEND(list, value)\n}\nnums ← []\nappendTwice(nums)\nDISPLAY(LENGTH(nums))","choices":["The call to appendTwice is missing the required second argument for value","The appendTwice procedure must RETURN the list instead of modifying it directly","The list nums cannot be empty when passed as an argument to the procedure","The function LENGTH cannot be used on lists that are modified inside procedures"],"correctIndex":0}
{"prompt":"Hard 09 (procedures + lists): maxValue should return the largest number, but it always returns the last one. Why?","code":"PROCEDURE maxValue(numbers) {\n  max ← numbers[1]\n  FOR EACH n IN numbers {\n    max ← n\n  }\n  RETURN(max)\n}\nvalues ← [2, 10, 5]\nDISPLAY(maxValue(values))","choices":["max is unconditionally overwritten with every element instead of checking if n > max","The variable max should be initialized to 0 regardless of the list contents","The FOR EACH loop should iterate through the list in reverse order","The RETURN(max) statement must be placed inside the FOR EACH loop body"],"correctIndex":0}
{"prompt":"Hard 10 (procedures + lists): countTarget should return how many times target appears. What is the bug?","code":"PROCEDURE countTarget(list, target) {\n  count ← 0\n  FOR EACH item IN list {\n    IF (item = target) {\n      count ← count + 1\n    }\n  }\n  RETURN(item)\n}\nvalues ← [1, 2, 1]\nDISPLAY(countTarget(values, 1))","choices":["It RETURNS the loop variable item instead of the counter variable count","The variable count should be decremented instead of incremented on match","The IF statement should compare target to the entire list, not item","The procedure requires a second parameter to hold the running count"],"correctIndex":0}
{"prompt":"Hard 11 (procedures + lists): firstElement should return the first item of list, but sometimes it crashes. Why?","code":"PROCEDURE firstElement(list) {\n  RETURN(list[1])\n}\nvalues ← []\nDISPLAY(firstElement(values))","choices":["It assumes list has at least one element and fails when passed an empty list","Index 1 is only valid if the list contains exactly one item, not more","The RETURN statement cannot be the very first line of a procedure definition","The input values must be a list of strings, not an empty list"],"correctIndex":0}
{"prompt":"Hard 12 (procedures + lists): This procedure should create a copy of a list. Why is the result incorrect?","code":"PROCEDURE copyList(original) {\n  copy ← original\n  RETURN(copy)\n}\nnums ← [1, 2, 3]\nclone ← copyList(nums)\nAPPEND(clone, 4)\nDISPLAY(LENGTH(nums))","choices":["copy becomes a reference to original, so modifying clone also modifies nums","copyList must use the INSERT command instead of assignment to copy values","Lists are complex types and cannot be returned from procedures in this language","The APPEND command is restricted and cannot be used on returned lists"],"correctIndex":0}
{"prompt":"Hard 13 (procedures + lists): This procedure should swap the first and last elements of list. What is the bug?","code":"PROCEDURE swapEnds(list) {\n  temp ← list[1]\n  list[1] ← list[LENGTH(list)]\n  list[LENGTH(list)] ← list[1]\n}\nnums ← [1, 2, 3]\nswapEnds(nums)\nDISPLAY(nums[1])","choices":["The last assignment puts the new list[1] value back instead of the saved temp value","The temp variable must be declared globally outside the procedure","LENGTH(list) cannot be called more than once within a single procedure","Lists with an odd number of values cannot have their ends swapped"],"correctIndex":0}
{"prompt":"Hard 14 (procedures + lists): indexOf is supposed to return the position of target, or 0 if not found. What is the bug?","code":"PROCEDURE indexOf(list, target) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      RETURN(index)\n    }\n    index ← index + 1\n  }\n  RETURN(-1)\n}\nvalues ← [5, 6]\nDISPLAY(indexOf(values, 4))","choices":["It returns -1 when target is not found, but the requirements say it should return 0","The loop iteration should start at index 0 instead of index 1","The REPEAT UNTIL condition must use index ≥ LENGTH(list) to work","The procedure indexOf should RETURN the list itself instead of an index"],"correctIndex":0}
{"prompt":"Hard 15 (procedures + lists): makeZeros should build a list of n zeros. What is wrong?","code":"PROCEDURE makeZeros(n) {\n  zeros ← []\n  i ← 1\n  REPEAT UNTIL (i > n) {\n    zeros[i] ← 0\n    i ← i + 1\n  }\n  RETURN(zeros)\n}\nresult ← makeZeros(3)\nDISPLAY(LENGTH(result))","choices":["It writes directly to zeros[i] instead of using APPEND, which requires existing indexes","The loop variable i should be initialized to 0 instead of 1","The variable zeros must be pre-filled with placeholder values before use","Lists that contain only zero values cannot be returned from procedures"],"correctIndex":0}
{"prompt":"Hard 16 (procedures + lists): This procedure should remove all negative numbers. Why is it buggy?","code":"PROCEDURE removeNegatives(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] < 0) {\n      REMOVE(list, index)\n      index ← index + 1\n    }\n    index ← index + 1\n  }\n}\nnums ← [1, -2, -3, 4]\nremoveNegatives(nums)\nDISPLAY(nums)","choices":["index is increased twice after a removal, so the next element is skipped","The IF statement should check for list[index] > 0 instead of < 0","The REMOVE command must be called with the value, not the index","The loop must run REPEAT LENGTH(list) TIMES instead of using UNTIL"],"correctIndex":0}
{"prompt":"Hard 17 (procedures + lists): joinLists should append items from listB to listA. What is the bug?","code":"PROCEDURE joinLists(listA, listB) {\n  FOR EACH item IN listB {\n    APPEND(listB, item)\n  }\n}\na ← [1, 2]\nb ← [3, 4]\njoinLists(a, b)\nDISPLAY(a)","choices":["It appends items back into listB, causing an infinite loop or modifying the wrong list","The FOR EACH loop must iterate over listA instead of listB","The procedure must RETURN listA for any changes to be visible","The APPEND command cannot be used inside a user-defined procedure"],"correctIndex":0}
{"prompt":"Hard 18 (procedures + lists): getEvens should return only the even numbers. Why is its return value wrong?","code":"PROCEDURE getEvens(list) {\n  evens ← []\n  FOR EACH value IN list {\n    IF (value MOD 2 = 0) {\n      APPEND(evens, value)\n    }\n  }\n  RETURN(list)\n}\nnums ← [1, 2, 3, 4]\nresult ← getEvens(nums)\nDISPLAY(LENGTH(result))","choices":["It returns the original list argument instead of the new evens list","The IF condition should use value MOD 2 ≠ 0 to find evens","The APPEND command is adding values to the list in the wrong order","The loop must stop execution after the first even value is found"],"correctIndex":0}
{"prompt":"Hard 19 (procedures + lists): reverse should return the list in reverse order, but it doesn’t. Why?","code":"PROCEDURE reverse(list) {\n  reversed ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(reversed, list[index])\n    index ← index + 1\n  }\n  RETURN(list)\n}\nnums ← [1, 2, 3]\nDISPLAY(reverse(nums))","choices":["It returns the original list instead of the newly created reversed list","The loop should count down from LENGTH(list) instead of up from 1","The APPEND command should insert items at the front of reversed","The variable reversed must be a reference to the same list as list"],"correctIndex":0}
{"prompt":"Hard 20 (procedures + lists): totalLength should return the total number of elements in both lists. What is the bug?","code":"PROCEDURE totalLength(listA, listB) {\n  RETURN(LENGTH(listA) + LENGTH(listA))\n}\na ← [1, 2]\nb ← [3, 4, 5]\nDISPLAY(totalLength(a, b))","choices":["It adds LENGTH(listA) to itself and ignores listB entirely","The RETURN result should be stored in a variable before being used","The function LENGTH cannot be called more than once in a procedure","The lists listA and listB must be the same length for this to work"],"correctIndex":0}
{"prompt":"Hard 21 (procedures + lists): contains should return TRUE if list has target. Why is it incorrect?","code":"PROCEDURE contains(list, target) {\n  FOR EACH item IN list {\n    IF (item = target) {\n      RETURN(TRUE)\n    }\n    ELSE {\n      RETURN(FALSE)\n    }\n  }\n}\nvalues ← [1, 2, 3]\nDISPLAY(contains(values, 3))","choices":["It returns FALSE after checking only the first item, so it never examines the rest of the list","The ELSE clause prevents RETURN(TRUE) from ever executing","The procedure must initialize a Boolean variable before the loop","FOR EACH loops automatically skip the first element in some pseudocode languages"],"correctIndex":0}
{"prompt":"Hard 22 (procedures + lists): scale should multiply each item in list by factor. Why doesn’t list change?","code":"PROCEDURE scale(list, factor) {\n  FOR EACH item IN list {\n    item ← item * factor\n  }\n}\nnums ← [1, 2, 3]\nscale(nums, 2)\nDISPLAY(nums[1])","choices":["Reassigning the loop variable item does not modify the underlying list element","The factor variable must be appended into the list before the loop runs","The procedure needs to RETURN the list for any changes to apply","The FOR EACH loop must use an index variable, not an element variable"],"correctIndex":0}
{"prompt":"Hard 23 (procedures + lists): findAllPositions should add all indices where target appears. What is the bug?","code":"PROCEDURE findAllPositions(list, target) {\n  positions ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      APPEND(positions, index)\n      RETURN(positions)\n    }\n    index ← index + 1\n  }\n  RETURN(positions)\n}\nvalues ← [1, 2, 1, 2]\nDISPLAY(findAllPositions(values, 2))","choices":["It returns as soon as the first match is found, ignoring subsequent matches","The positions list must start with at least one value already stored","The APPEND command should add list[index] instead of the index","The loop condition should be index ≥ LENGTH(list) instead of >"],"correctIndex":0}
{"prompt":"Hard 24 (procedures + lists): incrementAll should add 1 to every element and return the result. What is the bug?","code":"PROCEDURE incrementAll(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    list[index] ← list[index] + 1\n    index ← index + 1\n  }\n}\nnums ← [1, 2]\nresult ← incrementAll(nums)\nDISPLAY(result[1])","choices":["The procedure never returns the list, so result receives no value","The index variable should start at 0 instead of 1 for lists","The loop should use FOR EACH instead of a numeric index variable","It must use the APPEND command instead of assigning list[index] directly"],"correctIndex":0}
{"prompt":"Hard 25 (procedures + lists): makeRange should create the list [1, 2, ..., n]. What is the bug?","code":"PROCEDURE makeRange(n) {\n  range ← []\n  i ← 1\n  REPEAT UNTIL (i > n) {\n    APPEND(range, n)\n    i ← i + 1\n  }\n  RETURN(range)\n}\nresult ← makeRange(3)\nDISPLAY(result[1])","choices":["It appends n every time instead of i, creating a list of identical values","The loop should continue until i ≥ n instead of stopping when i > n","The variable range must not be initialized as an empty list","The procedure should display the range list instead of returning it"],"correctIndex":0}
{"prompt":"Hard 26 (procedures + lists): sumFirst should return the sum of the first k elements. What is the off-by-one bug?","code":"PROCEDURE sumFirst(list, k) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index ≥ k) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvalues ← [2, 4, 6]\nDISPLAY(sumFirst(values, 2))","choices":["It stops when index equals k, so the element at index k is excluded","The variable index should start at 0 instead of 1","The variable total must start at list[1] instead of 0","The loop should be REPEAT k TIMES rather than checking index"],"correctIndex":0}
{"prompt":"Hard 27 (procedures + lists): doubledCopy should create a new doubled list without changing original. Why is original changed?","code":"PROCEDURE doubledCopy(list) {\n  copy ← list\n  FOR EACH i IN copy {\n    i ← i * 2\n  }\n  RETURN(copy)\n}\nnums ← [1, 2]\nresult ← doubledCopy(nums)\nDISPLAY(nums[1])","choices":["copy is a reference to the same list as original, not a new independent copy","The FOR EACH loop must use list as the source, not copy","The procedure should modify list directly instead of using a copy","The RETURN(copy) statement must appear before the FOR EACH loop"],"correctIndex":0}
{"prompt":"Hard 28 (procedures + lists): minValue should return the smallest element. What is the bug?","code":"PROCEDURE minValue(numbers) {\n  min ← numbers[1]\n  FOR EACH n IN numbers {\n    IF (n < min) {\n      min ← min\n    }\n  }\n  RETURN(min)\n}\nvalues ← [5, 2, 9]\nDISPLAY(minValue(values))","choices":["Inside the IF, it assigns min to itself instead of updating it with n","The variable min must start at 0 regardless of the list contents","The comparison should be n > min to find the minimum value","The procedure must RETURN the list numbers instead of the value min"],"correctIndex":0}
{"prompt":"Hard 29 (procedures + lists): concatStrings should join all parts into one string. Why is it wrong?","code":"PROCEDURE concatStrings(list) {\n  result ← \"\"\n  FOR EACH part IN list {\n    result ← part\n  }\n  RETURN(result)\n}\nwords ← [\"A\", \"B\", \"C\"]\nDISPLAY(concatStrings(words))","choices":["It overwrites result each time instead of concatenating (result ← result + part)","The loop should stop execution after the first part is processed","The variable result must be a list type, not a string type","The concatStrings procedure must return the list instead of a string"],"correctIndex":0}
{"prompt":"Hard 30 (procedures + lists): countAboveAverage should return how many items are greater than the average. What is the bug?","code":"PROCEDURE countAboveAverage(numbers) {\n  total ← 0\n  FOR EACH n IN numbers {\n    total ← total + n\n  }\n  avg ← total / LENGTH(numbers)\n  count ← 0\n  FOR EACH n IN numbers {\n    IF (n > avg) {\n      count ← count + 1\n    }\n  }\n  RETURN(total)\n}\nvalues ← [1, 2, 3]\nDISPLAY(countAboveAverage(values))","choices":["It returns total (sum) instead of count, so the count is lost","The average calculation should divide by LENGTH(numbers) - 1","The second loop should use a different variable name for the item","The procedure must display count directly and not return it"],"correctIndex":0}
{"prompt":"Hard 31 (procedures + lists): isSorted should return TRUE if list is in ascending order. Why is it wrong?","code":"PROCEDURE isSorted(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > list[index + 1]) {\n      RETURN(FALSE)\n    }\n    index ← index + 1\n  }\n  RETURN(TRUE)\n}\nvalues ← [1, 2, 3]\nDISPLAY(isSorted(values))","choices":["When index is at the last element, list[index + 1] accesses an out-of-bounds index","The comparison operator should use ≥ instead of > for sorting","The loop should iterate backwards from the end of the list","The procedure should RETURN(FALSE) after the loop instead of TRUE"],"correctIndex":0}
{"prompt":"Hard 32 (procedures + lists): doubledNew should return a new doubled list and leave original unchanged. Why does original change?","code":"PROCEDURE doubledNew(list) {\n  newList ← list\n  FOR i FROM 1 TO LENGTH(newList) {\n    newList[i] ← newList[i] * 2\n  }\n  RETURN(newList)\n}\nnums ← [1, 2]\nresult ← doubledNew(nums)\nDISPLAY(nums[1])","choices":["newList is just another reference to list, so changing newList[i] also changes the original list","The FOR loop should start at index 0 instead of index 1 to avoid modifying the original list","The procedure must RETURN(list) instead of RETURN(newList) to prevent aliasing issues","The list nums cannot safely be passed as an argument to a procedure that uses a loop"],"correctIndex":0}
{"prompt":"Hard 33 (procedures + lists): addFront should put value at the beginning of list and return it. What is the bug?","code":"PROCEDURE addFront(list, value) {\n  INSERT(list, LENGTH(list), value)\n  RETURN(list)\n}\nnums ← [2, 3]\nDISPLAY(addFront(nums, 1)[1])","choices":["It inserts the value at the end of the list instead of at index 1","INSERT should be replaced with APPEND when adding the first element","The procedure must not return the list after calling INSERT","The value must be removed from the list before being inserted"],"correctIndex":0}
{"prompt":"Hard 34 (procedures + lists): clearList should remove all items, but some remain. Why?","code":"PROCEDURE clearList(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    REMOVE(list, index)\n    index ← index + 1\n  }\n}\nnums ← [1, 2, 3]\nclearList(nums)\nDISPLAY(LENGTH(nums))","choices":["Removing an item shifts elements left, but index increments, causing items to be skipped","The loop should use REPEAT LENGTH(list) TIMES and ignore index changes","The REMOVE command should be called with the value, not the index","The clearList procedure must RETURN the list to remove items"],"correctIndex":0}
{"prompt":"Hard 35 (procedures + lists): positives should return a list of positive numbers. Why may it crash?","code":"PROCEDURE positives(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > 0) {\n      APPEND(result, list[index])\n    }\n    index ← index + 1\n  }\n  RETURN(result[1])\n}\nnums ← [-1, -2]\nDISPLAY(positives(nums))","choices":["If no positive numbers exist, result is empty and result[1] causes an error","The result list must start with at least one placeholder element","The IF statement should use list[index] ≥ 0 instead of > 0","The APPEND command must be placed outside the loop, not inside"],"correctIndex":0}
{"prompt":"Hard 36 (procedures + lists): middleElement should return the middle value for an odd-length list. What is the bug?","code":"PROCEDURE middleElement(list) {\n  index ← LENGTH(list) / 2\n  RETURN(list[index])\n}\nvalues ← [1, 3, 5]\nDISPLAY(middleElement(values))","choices":["For odd lengths, LENGTH(list) / 2 truncates down; it should be LENGTH(list) / 2 + 1","The procedure must use a loop to find the middle instead of division","The middle element is always located at index 1 in AP CSP lists","It should return the value LENGTH(list) instead of a list element"],"correctIndex":0}
{"prompt":"Hard 37 (procedures + lists): removeFirstMatch should remove the first occurrence of target. Why might it remove the wrong element?","code":"PROCEDURE removeFirstMatch(list, target) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      REMOVE(list, index + 1)\n      RETURN(TRUE)\n    }\n    index ← index + 1\n  }\n  RETURN(FALSE)\n}\nvals ← [4, 5, 5, 6]\nremoveFirstMatch(vals, 5)\nDISPLAY(vals)","choices":["It removes at index + 1 instead of index, deleting the element after the match","The procedure must return the updated list, not a Boolean value","The loop should continue running after removing instead of returning","The target variable must be at the front of the list for this to work"],"correctIndex":0}
{"prompt":"Hard 38 (procedures + lists): firstTwo should return the first two elements in a new list. What is the bug?","code":"PROCEDURE firstTwo(list) {\n  result ← []\n  APPEND(result, list[1])\n  APPEND(result, list[1])\n  RETURN(result)\n}\nnums ← [9, 8, 7]\nDISPLAY(firstTwo(nums))","choices":["It appends the first element list[1] twice instead of list[1] and list[2]","The result list should be initialized with [0, 0]","The APPEND command must not be used twice in succession","The procedure should modify the original list directly instead of returning"],"correctIndex":0}
{"prompt":"Hard 39 (procedures + lists): sumEvenPositions should sum values at positions 2, 4, 6, and so on. Why is the sum wrong?","code":"PROCEDURE sumEvenPositions(list) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (index MOD 2 = 0) {\n      total ← total + list[index]\n    }\n    index ← index + 2\n  }\n  RETURN(total)\n}\nvals ← [1, 2, 3, 4]\nDISPLAY(sumEvenPositions(vals))","choices":["index skips by 2 starting from 1 (1, 3, 5...), so MOD 2 = 0 is never true","The IF condition should test for index MOD 2 ≠ 0","The loop should start with index ← 2 instead of index ← 1","The variable total should be reset to 0 inside the loop"],"correctIndex":0}
{"prompt":"Hard 40 (procedures + lists): copyWithoutFirst should return all elements except the first one. What is the bug?","code":"PROCEDURE copyWithoutFirst(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nnums ← [5, 6, 7]\nDISPLAY(copyWithoutFirst(nums))","choices":["It copies every element starting at index 1; it should start at index 2","The result list should be initialized with the first element","The loop should stop when index ≥ LENGTH(list)","The APPEND command must use index 1 for every insertion"],"correctIndex":0}
{"prompt":"Hard 41 (procedures + lists): anyNegative should return TRUE if there is at least one negative value. Why is it incorrect?","code":"PROCEDURE anyNegative(list) {\n  FOR EACH val IN list {\n    IF (val < 0) {\n      RETURN(FALSE)\n    }\n  }\n  RETURN(TRUE)\n}\nnums ← [1, -2, 3]\nDISPLAY(anyNegative(nums))","choices":["It returns FALSE when it sees a negative, but logic requires TRUE for negatives","The IF statement should compare val to a Boolean instead of 0","The FOR EACH loop must be replaced with a REPEAT UNTIL loop","It should only check the first element, not the entire list"],"correctIndex":0}
{"prompt":"Hard 42 (procedures + lists): lastIndexOf should return the last index where target appears. What is the bug?","code":"PROCEDURE lastIndexOf(list, target) {\n  index ← 1\n  last ← 0\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      last ← index\n      RETURN(last)\n    }\n    index ← index + 1\n  }\n  RETURN(last)\n}\nvals ← [2, 3, 2, 4]\nDISPLAY(lastIndexOf(vals, 2))","choices":["It returns immediately on the first match, preventing it from finding later matches","The variable last should be initialized to 1 instead of 0","The loop should run backwards from the end of the list","It should use the INSERT command instead of RETURN for last"],"correctIndex":0}
{"prompt":"Hard 43 (procedures + lists): mergeLengths should return a list [LENGTH(a), LENGTH(b)]. Why is the result wrong?","code":"PROCEDURE mergeLengths(a, b) {\n  result ← []\n  APPEND(result, LENGTH(a))\n  APPEND(result, LENGTH(a))\n  RETURN(result)\n}\nx ← [1]\ny ← [2, 3]\nDISPLAY(mergeLengths(x, y))","choices":["It appends LENGTH(a) twice instead of appending LENGTH(a) then LENGTH(b)","It should append the lists a and b themselves, not their lengths","The result list should start with two placeholder values","The procedure must RETURN the lists a and b, not result"],"correctIndex":0}
{"prompt":"Hard 44 (procedures + lists): prefixSum should return a list where each element is the sum up to that position. What is the bug?","code":"PROCEDURE prefixSum(list) {\n  sums ← []\n  running ← 0\n  FOR EACH value IN list {\n    running ← running + value\n  }\n  RETURN(sums)\n}\nnums ← [1, 2, 3]\nDISPLAY(prefixSum(nums))","choices":["It calculates running total but never appends it to sums, so sums is empty","The variable running should be declared inside the loop","The FOR EACH loop cannot be used with running totals","The procedure should return the variable running instead of sums"],"correctIndex":0}
{"prompt":"Hard 45 (procedures + lists): getFirstOddIndex should return the index of the first odd value or 0 if none. What is the bug?","code":"PROCEDURE getFirstOddIndex(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] MOD 2 = 1) {\n      RETURN(TRUE)\n    }\n    index ← index + 1\n  }\n  RETURN(0)\n}\nvalues ← [2, 4, 5]\nDISPLAY(getFirstOddIndex(values))","choices":["It returns TRUE instead of the specific index when it finds an odd value","The IF statement must use list[index] MOD 2 = 0","The final RETURN(0) should be placed inside the loop","The index variable should be initialized to 0 instead of 1"],"correctIndex":0}
{"prompt":"Hard 46 (procedures + lists): removeAllTarget should remove every occurrence of target. Why does it miss some?","code":"PROCEDURE removeAllTarget(list, target) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = target) {\n      REMOVE(list, index)\n      index ← index + 1\n    }\n    index ← index + 1\n  }\n}\nvals ← [1, 2, 2, 3]\nremoveAllTarget(vals, 2)\nDISPLAY(vals)","choices":["After removing, items shift left, but index increments anyway, skipping the next item","The IF statement should check list[index] ≠ target","The REMOVE command must be called with target, not index","The loop should stop execution after the first removal"],"correctIndex":0}
{"prompt":"Hard 47 (procedures + lists): countUnique should count how many different values are in the list. Why is this approach wrong?","code":"PROCEDURE countUnique(list) {\n  RETURN(LENGTH(list))\n}\nvals ← [1, 1, 2]\nDISPLAY(countUnique(vals))","choices":["It returns the total number of elements without checking for duplicates","It should always return 0 for any list with repeated values","The procedure countUnique must sort the list before returning","The function LENGTH cannot be used for lists that contain duplicates"],"correctIndex":0}
{"prompt":"Hard 48 (procedures + lists): firstNonZero should return the first nonzero value. Why might this crash?","code":"PROCEDURE firstNonZero(list) {\n  index ← 1\n  REPEAT UNTIL (list[index] ≠ 0) {\n    index ← index + 1\n  }\n  RETURN(list[index])\n}\nvals ← [0, 0, 0]\nDISPLAY(firstNonZero(vals))","choices":["If the list contains only zeros, index increments past the end, causing an error","The loop should use REPEAT UNTIL (index > LENGTH(list))","It must return the index variable instead of list[index]","Nonzero values cannot be stored in lists in this language"],"correctIndex":0}
{"prompt":"Hard 49 (procedures + lists): findLast should return the last element greater than limit. What is the bug?","code":"PROCEDURE findLast(list, limit) {\n  last ← -1\n  FOR EACH value IN list {\n    IF (value > limit) {\n      last ← value\n      RETURN(last)\n    }\n  }\n  RETURN(last)\n}\nvals ← [3, 7, 5]\nDISPLAY(findLast(vals, 4))","choices":["It returns immediately after the first match, missing any later matches","The variable last should store the index, not the value","The IF statement must use value ≥ limit","The RETURN(last) statement after the loop should be removed"],"correctIndex":0}
{"prompt":"Hard 50 (procedures + lists): sumExceptFirst should sum all values except the first. Why is the sum off by one element?","code":"PROCEDURE sumExceptFirst(list) {\n  total ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    total ← total + list[index]\n    index ← index + 1\n  }\n  RETURN(total)\n}\nvals ← [5, 1, 2]\nDISPLAY(sumExceptFirst(vals))","choices":["It starts summing at index 1, so the first element is included instead of skipped","The loop condition should stop at index ≥ LENGTH(list)","The variable total should start at list[1]","It must subtract the first element at the end instead of skipping it"],"correctIndex":0}
{"prompt":"Hard 51 (procedures + lists): getOdds should collect all odd values into a new list. Why is original list changed?","code":"PROCEDURE getOdds(list) {\n  odds ← list\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(odds)) {\n    IF (odds[index] MOD 2 = 0) {\n      REMOVE(odds, index)\n    }\n    ELSE {\n      index ← index + 1\n    }\n  }\n  RETURN(odds)\n}\nnums ← [1, 2, 3]\nresult ← getOdds(nums)\nDISPLAY(nums)","choices":["odds is assigned as a reference to list, so changes to odds also affect list","The IF statement should remove odd values instead of even ones","The ELSE block should not update the index variable","getOdds must rebuild odds using APPEND instead of REMOVE"],"correctIndex":0}
{"prompt":"Hard 52 (procedures + lists): copyHead should copy the first k elements into a new list. Why is the new list too long?","code":"PROCEDURE copyHead(list, k) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [4, 5, 6]\nDISPLAY(copyHead(vals, 2))","choices":["The loop condition ignores k, so it copies the entire list","The loop should start with index ← 0","The APPEND command should stop after two elements","The procedure should return list instead of result"],"correctIndex":0}
{"prompt":"Hard 53 (procedures + lists): sum2DRow should sum the values in a particular row of a 2D list. What is the bug?","code":"PROCEDURE sum2DRow(grid, row) {\n  total ← 0\n  col ← 1\n  REPEAT UNTIL (col > LENGTH(grid)) {\n    total ← total + grid[row][col]\n    col ← col + 1\n  }\n  RETURN(total)\n}\nnums ← [[1, 2], [3, 4]]\nDISPLAY(sum2DRow(nums, 1))","choices":["It uses LENGTH(grid) which is the number of rows, instead of LENGTH(grid[row])","The row parameter should always be 1 for the first row","The inner indexing grid[row][col] is syntax that is invalid in AP CSP","The variable total must start at grid[row][1]"],"correctIndex":0}
{"prompt":"Hard 54 (procedures + lists): flatten2 should merge two lists into one. Why is one list missing?","code":"PROCEDURE flatten2(a, b) {\n  result ← []\n  FOR EACH x IN a {\n    APPEND(result, x)\n  }\n  RETURN(result)\n}\nvalsA ← [1, 2]\nvalsB ← [3, 4]\nDISPLAY(flatten2(valsA, valsB))","choices":["It only processes list a and never iterates over list b","The variable result should be initialized with list a","The FOR EACH loop must iterate over result, not a","The procedure must RETURN list b as well"],"correctIndex":0}
{"prompt":"Hard 55 (procedures + lists): reverseCopy should return a reversed list without changing the original. Why is result empty?","code":"PROCEDURE reverseCopy(list) {\n  result ← []\n  index ← LENGTH(list)\n  REPEAT UNTIL (index < 1) {\n    index ← index - 1\n  }\n  RETURN(result)\n}\nnums ← [1, 2]\nDISPLAY(reverseCopy(nums))","choices":["The loop updates index but never performs an APPEND to the result list","The variable result should start as a copy of list","The index variable should start at 1 and increment","The RETURN statement must be placed inside the loop"],"correctIndex":0}
{"prompt":"Hard 56 (procedures + lists): This procedure counts how many items match target. Why is the count wrong?","code":"PROCEDURE countMatches(list, target) {\n  count ← 0\n  FOR EACH item IN list {\n    IF (item = target) {\n      count ← item\n    }\n  }\n  RETURN(count)\n}\nvals ← [5, 5, 5]\nDISPLAY(countMatches(vals, 5))","choices":["It assigns the item value to count instead of incrementing count by 1","The loop should use REPEAT UNTIL instead of FOR EACH","The variable count must be initialized to 1","The IF statement should check item ≠ target"],"correctIndex":0}
{"prompt":"Hard 57 (procedures + lists): This procedure should move the first element to the end. What is the bug?","code":"PROCEDURE rotateLeft(list) {\n  first ← list[1]\n  REMOVE(list, 1)\n  RETURN(list)\n}\nnums ← [1, 2, 3]\nDISPLAY(rotateLeft(nums))","choices":["It removes the first element but fails to APPEND it to the end of the list","The variable first should be stored at list[LENGTH(list)]","The REMOVE command should be called on the last element","The procedure should return the variable first instead of list"],"correctIndex":0}
{"prompt":"Hard 58 (procedures + lists): allPositive should return TRUE only if all numbers are positive. Why is it wrong?","code":"PROCEDURE allPositive(list) {\n  FOR EACH n IN list {\n    IF (n > 0) {\n      RETURN(TRUE)\n    }\n  }\n  RETURN(FALSE)\n}\nvals ← [1, -5, 3]\nDISPLAY(allPositive(vals))","choices":["It returns TRUE immediately upon finding one positive number, ignoring subsequent negatives","The IF statement should check for n < 0","The FOR EACH loop must be replaced by REPEAT UNTIL","The value FALSE should be returned inside the loop"],"correctIndex":0}
{"prompt":"Hard 59 (procedures + lists): This code should return the second largest value. What is the bug?","code":"PROCEDURE secondLargest(list) {\n  max ← 0\n  sec ← 0\n  FOR EACH n IN list {\n    IF (n > max) {\n      max ← n\n    }\n  }\n  RETURN(sec)\n}\nvals ← [10, 20, 5]\nDISPLAY(secondLargest(vals))","choices":["The logic updates max but never updates the variable sec, so it remains 0","The variable max should be initialized to list[1]","The variable sec should be returned before the loop starts","The loop should iterate exactly twice"],"correctIndex":0}
{"prompt":"Hard 60 (procedures + lists): swapPairs should swap (1,2), (3,4), etc. Why does it crash or fail?","code":"PROCEDURE swapPairs(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    temp ← list[index]\n    list[index] ← list[index+1]\n    list[index+1] ← temp\n    index ← index + 1\n  }\n}\nnums ← [1, 2, 3, 4]\nswapPairs(nums)","choices":["index+1 eventually goes out of bounds when index reaches the last element","index increments by 1, so it incorrectly re-swaps overlapping pairs","The temp variable must be declared outside the loop","The list must contain an odd number of elements for swapping to work"],"correctIndex":0}
{"prompt":"Hard 61 (procedures + lists): This procedure calculates sum of squares. Why is the result smaller than expected?","code":"PROCEDURE sumSquares(list) {\n  sum ← 0\n  FOR EACH n IN list {\n    sum ← n * n\n  }\n  RETURN(sum)\n}\nvals ← [2, 3]\nDISPLAY(sumSquares(vals))","choices":["It overwrites sum with the square each time instead of adding to the total","The variable sum should start at 1","The calculation n * n should be enclosed in parentheses","The procedure should return the list instead of sum"],"correctIndex":0}
{"prompt":"Hard 62 (procedures + lists): filterSmall should remove numbers less than 10. Why is the logic flawed?","code":"PROCEDURE filterSmall(list) {\n  result ← []\n  FOR EACH n IN list {\n    IF (n > 10) {\n      APPEND(result, n)\n    }\n  }\n  RETURN(list)\n}\nnums ← [5, 12, 8]\nDISPLAY(filterSmall(nums))","choices":["It returns the original list instead of the filtered result list","The condition should be n ≥ 10","The variable result should be initialized with list","The APPEND command should be used on list, not result"],"correctIndex":0}
{"prompt":"Hard 63 (procedures + lists): This procedure should return the range (max - min). Why does it fail?","code":"PROCEDURE getRange(list) {\n  max ← 0\n  min ← 0\n  FOR EACH n IN list {\n    IF (n > max) { max ← n }\n    IF (n < min) { min ← n }\n  }\n  RETURN(max - min)\n}\nvals ← [10, 20, 30]\nDISPLAY(getRange(vals))","choices":["min is initialized to 0, so it remains 0 unless the list has negative numbers","max should start at list[1]","The loop should be REPEAT UNTIL","It should return max + min"],"correctIndex":0}
{"prompt":"Hard 64 (procedures + lists): hasDuplicates should return TRUE if any value appears twice. Why is it wrong?","code":"PROCEDURE hasDuplicates(list) {\n  FOR EACH item IN list {\n    IF (item = item) {\n      RETURN(TRUE)\n    }\n  }\n  RETURN(FALSE)\n}\nvals ← [1, 2, 3]\nDISPLAY(hasDuplicates(vals))","choices":["It compares item to itself, which is always true, returning TRUE immediately","The loop should be a nested loop","The value FALSE should be returned inside the loop","The procedure must sort the list first"],"correctIndex":0}
{"prompt":"Hard 65 (procedures + lists): This code sums indices, not values. What is the bug?","code":"PROCEDURE sumIndices(list) {\n  total ← 0\n  FOR EACH item IN list {\n    total ← total + item\n  }\n  RETURN(total)\n}\nnums ← [10, 20, 30]\nDISPLAY(sumIndices(nums))","choices":["It sums the values (item) instead of the indices because FOR EACH iterates over elements","The total variable should start at 1","FOR EACH loops cannot access indices directly","The procedure should return the list"],"correctIndex":0}
{"prompt":"Hard 66 (procedures + lists): productList should multiply all items. Why is the result 0?","code":"PROCEDURE productList(list) {\n  prod ← 0\n  FOR EACH n IN list {\n    prod ← prod * n\n  }\n  RETURN(prod)\n}\nvals ← [2, 3, 4]\nDISPLAY(productList(vals))","choices":["prod starts at 0, making all multiplication results 0","The loop should use REPEAT UNTIL","n should be initialized to 1","RETURN must be inside the loop"],"correctIndex":0}
{"prompt":"Hard 67 (procedures + lists): countEvens should return the number of even values. What is the bug?","code":"PROCEDURE countEvens(list) {\n  count ← 0\n  FOR EACH n IN list {\n    IF (n / 2 = 0) {\n      count ← count + 1\n    }\n  }\n  RETURN(count)\n}\nnums ← [2, 4, 5]\nDISPLAY(countEvens(nums))","choices":["It checks division (n / 2 = 0) which is only true for 0 or small fractions, not evens","count should start at 1","The IF condition should be n MOD 2 ≠ 0","RETURN should be inside the IF"],"correctIndex":0}
{"prompt":"Hard 68 (procedures + lists): This procedure copies a list but misses the last element. Why?","code":"PROCEDURE partialCopy(list) {\n  result ← []\n  index ← 1\n  REPEAT UNTIL (index = LENGTH(list)) {\n    APPEND(result, list[index])\n    index ← index + 1\n  }\n  RETURN(result)\n}\nvals ← [1, 2, 3]\nDISPLAY(partialCopy(vals))","choices":["The loop terminates when index equals length, so the last item is never copied","index should start at 0","APPEND should use index - 1","The condition should be index < LENGTH(list)"],"correctIndex":0}
{"prompt":"Hard 69 (procedures + lists): findMinIndex should return the index of the smallest value. What is the bug?","code":"PROCEDURE findMinIndex(list) {\n  minVal ← list[1]\n  minIdx ← 1\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] < minVal) {\n      minVal ← list[index]\n    }\n    index ← index + 1\n  }\n  RETURN(minIdx)\n}\nnums ← [5, 2, 8]\nDISPLAY(findMinIndex(nums))","choices":["It updates minVal when a smaller value is found but fails to update minIdx","minIdx should start at 0","The loop should start at index 1","It should return minVal instead"],"correctIndex":0}
{"prompt":"Hard 70 (procedures + lists): This procedure should append a value only if it's not already there. Why does it duplicate?","code":"PROCEDURE addUnique(list, val) {\n  FOR EACH item IN list {\n    IF (item ≠ val) {\n      APPEND(list, val)\n      RETURN(list)\n    }\n  }\n}\nnums ← [1, 2]\naddUnique(nums, 1)","choices":["It appends immediately upon finding the first non-matching element","The loop should check item = val","APPEND cannot be used inside loops","The procedure needs to return TRUE"],"correctIndex":0}
{"prompt":"Hard 71 (procedures + lists): reverseInPlace tries to reverse a list without a new one. Why does it fail?","code":"PROCEDURE reverseInPlace(list) {\n  left ← 1\n  right ← LENGTH(list)\n  REPEAT UNTIL (left = right) {\n    temp ← list[left]\n    list[left] ← list[right]\n    list[right] ← temp\n    left ← left + 1\n  }\n}\nvals ← [1, 2, 3, 4]\nreverseInPlace(vals)","choices":["For even-length lists, left and right cross each other without ever being equal, causing an infinite loop","The variable left should decrement","The variable right should increment","The temp variable is unnecessary"],"correctIndex":0}
{"prompt":"Hard 72 (procedures + lists): shiftRight should move elements to the right. Why is the last element lost?","code":"PROCEDURE shiftRight(list) {\n  last ← list[LENGTH(list)]\n  REMOVE(list, LENGTH(list))\n  INSERT(list, 0, last)\n}\nnums ← [1, 2, 3]\nshiftRight(nums)","choices":["INSERT uses index 0, which is invalid because AP CSP lists start at index 1","REMOVE should be at index 1","last should be stored after removal","The procedure must return the list"],"correctIndex":0}
{"prompt":"Hard 73 (procedures + lists): This procedure merges two sorted lists. Why does it crash if lists are different sizes?","code":"PROCEDURE merge(a, b) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(a)) {\n    IF (a[index] < b[index]) {\n      DISPLAY(a[index])\n    }\n    index ← index + 1\n  }\n}\nlistA ← [1, 5]\nlistB ← [2]\nmerge(listA, listB)","choices":["It tries to access b[index] even when index exceeds the length of list b","The loop should run until LENGTH(b)","The IF statement should check > instead of <","The DISPLAY command should be RETURN"],"correctIndex":0}
{"prompt":"Hard 74 (procedures + lists): countOccurrences counts how many times val appears. What is the bug?","code":"PROCEDURE countOccurrences(list, val) {\n  count ← 0\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] = val) {\n      count ← count + 1\n      REMOVE(list, index)\n    }\n    index ← index + 1\n  }\n  RETURN(count)\n}\nnums ← [1, 2, 2, 3]\nDISPLAY(countOccurrences(nums, 2))","choices":["Removing an element shifts indices left, but index increments anyway, skipping the next element","count should start at 1","REMOVE should be outside the IF","The loop should be FOR EACH"],"correctIndex":0}
{"prompt":"Hard 75 (procedures + lists): This procedure should return a list of squares. Why is the result empty?","code":"PROCEDURE getSquares(list) {\n  result ← []\n  FOR EACH n IN list {\n    sq ← n * n\n  }\n  RETURN(result)\n}\nnums ← [2, 3]\nDISPLAY(getSquares(nums))","choices":["It calculates sq but never APPENDs it to the result list","result should be initialized with list","FOR EACH cannot calculate squares","RETURN should be inside the loop"],"correctIndex":0}
{"prompt":"Hard 76 (procedures + lists): sumMatrix should sum all elements in a 2D grid. Why does it fail?","code":"PROCEDURE sumMatrix(grid) {\n  total ← 0\n  FOR EACH row IN grid {\n    total ← total + row\n  }\n  RETURN(total)\n}\nmat ← [[1, 2], [3, 4]]\nDISPLAY(sumMatrix(mat))","choices":["It attempts to add a list (row) to a number (total) instead of summing the row elements","total should start at 1","The loop should be REPEAT UNTIL","grid must be a 1D list"],"correctIndex":0}
{"prompt":"Hard 77 (procedures + lists): getMiddle should return the middle element. Why is the index calculation wrong?","code":"PROCEDURE getMiddle(list) {\n  mid ← LENGTH(list) MOD 2\n  RETURN(list[mid])\n}\nvals ← [10, 20, 30]\nDISPLAY(getMiddle(vals))","choices":["MOD 2 returns the remainder (0 or 1), not the middle index","mid should be LENGTH(list) * 2","RETURN should be list[mid+1]","LENGTH cannot be used inside a procedure"],"correctIndex":0}
{"prompt":"Hard 78 (procedures + lists): maxDifference should return max - min. What is the bug?","code":"PROCEDURE maxDifference(list) {\n  max ← 0\n  min ← 0\n  FOR EACH n IN list {\n    IF (n > max) { max ← n }\n    IF (n < min) { min ← n }\n  }\n  RETURN(max - min)\n}\nnums ← [5, 10, 2]\nDISPLAY(maxDifference(nums))","choices":["min is initialized to 0, which is smaller than positive list values, so min never updates","max should start at list[1]","The loop should be REPEAT UNTIL","It should return max + min"],"correctIndex":0}
{"prompt":"Hard 79 (procedures + lists): This procedure removes elements larger than limit. Why is it buggy?","code":"PROCEDURE removeLarge(list, limit) {\n  FOR EACH item IN list {\n    IF (item > limit) {\n      REMOVE(list, item)\n    }\n  }\n}\nvals ← [10, 20, 5]\nremoveLarge(vals, 15)","choices":["REMOVE expects an index, but item is the value","FOR EACH cannot be used with REMOVE","limit must be a string","The procedure must return list"],"correctIndex":0}
{"prompt":"Hard 80 (procedures + lists): swapFirstTwo should swap the first two items. Why does list not change?","code":"PROCEDURE swapFirstTwo(list) {\n  a ← list[1]\n  b ← list[2]\n  a ← b\n  b ← a\n}\nnums ← [1, 2, 3]\nswapFirstTwo(nums)","choices":["It updates the local variables a and b, not the actual list elements","a and b need to be initialized to 0","The procedure should return list","The loop is missing"],"correctIndex":0}
{"prompt":"Hard 81 (procedures + lists): fillList should create a list of size n with value v. Why is it infinite?","code":"PROCEDURE fillList(n, v) {\n  list ← []\n  count ← 1\n  REPEAT UNTIL (count > n) {\n    APPEND(list, v)\n  }\n  RETURN(list)\n}\nres ← fillList(3, 5)","choices":["The variable count is never incremented inside the loop","The condition should be count < n","list must be initialized with n elements","APPEND needs an index"],"correctIndex":0}
{"prompt":"Hard 82 (procedures + lists): containsZero should return TRUE if 0 is found. Why is it wrong?","code":"PROCEDURE containsZero(list) {\n  FOR EACH n IN list {\n    IF (n = 0) {\n      RETURN(TRUE)\n    }\n    ELSE {\n      RETURN(FALSE)\n    }\n  }\n}\nvals ← [1, 0, 2]","choices":["It returns FALSE immediately if the first element is not 0","The ELSE should be outside the loop","TRUE must be a string","FOR EACH needs an index"],"correctIndex":0}
{"prompt":"Hard 83 (procedures + lists): doubleList should double every element. Why does it crash?","code":"PROCEDURE doubleList(list) {\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(list)) {\n    list[index] ← list[index] * 2\n  }\n  index ← index + 1\n}\nnums ← [1, 2]","choices":["The index increment is placed outside the loop, causing an infinite loop","The condition should be index ≥ LENGTH(list)","list must be returned","list[index] is read-only"],"correctIndex":0}
{"prompt":"Hard 84 (procedures + lists): This procedure counts strings longer than 3 chars. What is the bug?","code":"PROCEDURE countLongStrings(list) {\n  count ← 0\n  FOR EACH s IN list {\n    IF (LENGTH(s) > 3) {\n      count ← count + 1\n    }\n  }\n  DISPLAY(count)\n}\nwords ← [\"hi\", \"hello\"]\ncountLongStrings(words)","choices":["It displays count but does not return it for use by the caller","count should start at 1","LENGTH(s) works only on lists","The loop should be REPEAT UNTIL"],"correctIndex":0}
{"prompt":"Hard 85 (procedures + lists): findMaxIndex returns the index of the max value. What is the bug?","code":"PROCEDURE findMaxIndex(list) {\n  maxVal ← list[1]\n  maxIdx ← 1\n  index ← 2\n  REPEAT UNTIL (index > LENGTH(list)) {\n    IF (list[index] > maxVal) {\n      maxVal ← list[index]\n    }\n    index ← index + 1\n  }\n  RETURN(maxIdx)\n}\nnums ← [10, 50, 20]","choices":["It updates maxVal but fails to update maxIdx to the new index","maxIdx should start at 0","The loop should start at index 1","It should return maxVal"],"correctIndex":0}
{"prompt":"Hard 86 (procedures + lists): averagePositive calculates avg of positive numbers. Why is it wrong?","code":"PROCEDURE averagePositive(list) {\n  sum ← 0\n  count ← 0\n  FOR EACH n IN list {\n    IF (n > 0) {\n      sum ← sum + n\n      count ← count + 1\n    }\n  }\n  RETURN(sum / LENGTH(list))\n}\nvals ← [10, -5, 10]","choices":["It divides by the total length of the list instead of count (the number of positives)","sum should start at 1","count is unnecessary","The IF condition should be n ≥ 0"],"correctIndex":0}
{"prompt":"Hard 87 (procedures + lists): isPalindromic checks if list reads same forwards/backwards. Why does it fail?","code":"PROCEDURE isPalindromic(list) {\n  rev ← reverse(list)\n  IF (list = rev) {\n    RETURN(TRUE)\n  }\n  RETURN(FALSE)\n}\nnums ← [1, 2, 3]","choices":["reverse(list) might modify list in place if not implemented as a pure function","The IF syntax is wrong","RETURN must be outside IF","TRUE should be a string"],"correctIndex":0}
{"prompt":"Hard 88 (procedures + lists): appendN is meant to always change list, but the call appendN(nums, 5, 0) produces no change. Why?","code":"PROCEDURE appendN(list, val, n) {\n  REPEAT n TIMES {\n    APPEND(list, val)\n  }\n  RETURN(list)\n}\nnums ← []\nappendN(nums, 5, 0)","choices":["When n is 0, the REPEAT loop never runs, so the list remains unchanged","APPEND requires a numeric index instead of relying on the end of the list","n must be at least 1 for REPEAT to be valid","val must be wrapped in a list before being appended"],"correctIndex":0}
{"prompt":"Hard 89 (procedures + lists): filterEven keeps only even numbers. Why is the result empty?","code":"PROCEDURE filterEven(list) {\n  result ← []\n  FOR EACH n IN list {\n    IF (n MOD 2 = 1) {\n      APPEND(result, n)\n    }\n  }\n  RETURN(result)\n}\nnums ← [2, 4, 6]","choices":["The logic checks for odd numbers (MOD 2 = 1) instead of evens","result should be initialized with list","APPEND should be REMOVE","The loop should be REPEAT UNTIL"],"correctIndex":0}
{"prompt":"Hard 90 (procedures + lists): This procedure removes duplicates. Why does it crash?","code":"PROCEDURE unique(list) {\n  res ← []\n  FOR EACH item IN list {\n    IF (NOT (contains(res, item))) {\n      APPEND(res, item)\n    }\n  }\n  RETURN(res)\n}\nnums ← [1, 1, 2]","choices":["If the helper procedure contains() is not defined, this will crash","res must be size of list","FOR EACH cannot be used","NOT syntax is invalid"],"correctIndex":0}
{"prompt":"Hard 91 (procedures + lists): This procedure is meant to sort the list. Why does it not work?","code":"PROCEDURE simpleSort(list) {\n  FOR i FROM 1 TO LENGTH(list) {\n    IF (list[i] > list[i + 1]) {\n      temp ← list[i]\n      list[i] ← list[i + 1]\n      list[i + 1] ← temp\n    }\n  }\n  RETURN(list)\n}","choices":["The loop variable i reaches LENGTH(list), so list[i + 1] is out of bounds","The temp variable must be declared outside the loop","The IF condition should use ≥ instead of >","You cannot assign new values to list elements inside a FOR loop"],"correctIndex":0}
{"prompt":"Hard 92 (procedures + lists): getElementAt should return item at index. What is the bug?","code":"PROCEDURE getElementAt(list, index) {\n  RETURN(list[index])\n}\nnums ← [1, 2, 3]\nDISPLAY(getElementAt(nums, 4))","choices":["Accessing index 4 in a list of size 3 causes an out-of-bounds error","The procedure must return list","Index starts at 0","RETURN must be in a loop"],"correctIndex":0}
{"prompt":"Hard 93 (procedures + lists): This procedure is intended to sum two lists element-wise. Why does it fail before producing any results?","code":"PROCEDURE sumLists(a, b) {\n  res ← []\n  index ← 1\n  REPEAT UNTIL (index > LENGTH(a)) {\n    APPEND(res, a[index] + b[index])\n    // missing index update\n  }\n  RETURN(res)\n}\nlistA ← [1, 2]\nlistB ← [1]","choices":["index is never incremented inside the loop, causing an infinite loop","Lists a and b must be the same length before the loop runs","res must be initialized with placeholder values before APPEND","APPEND must specify the target index instead of adding to the end"],"correctIndex":0}
{"prompt":"Hard 94 (procedures + lists): This procedure is intended to compute the range (max − min) of the numbers in list. What is the logic error that can cause an incorrect result for some lists?","code":"PROCEDURE range(list) {\n  max ← 0\n  min ← 100\n  FOR EACH n IN list {\n    IF (n > max) { max ← n }\n    IF (n < min) { min ← n }\n  }\n  RETURN(max - min)\n}","choices":["min is initialized to 100, so for lists whose values are all greater than 100, the min check never succeeds and min never changes","max should be initialized to the first element of the list instead of 0","min should be assigned only once after the loop finishes, not inside it","The FOR EACH loop must be replaced with an index-based loop for max and min to be updated correctly"],"correctIndex":0}
{"prompt":"Hard 95 (procedures + lists): This procedure checks if list is empty. Why is it wrong?","code":"PROCEDURE isEmpty(list) {\n  IF (LENGTH(list) = 1) {\n    RETURN(TRUE)\n  }\n  RETURN(FALSE)\n}","choices":["It checks if length is 1 instead of 0 to determine emptiness","TRUE should be returned at end","FALSE should be TRUE","LENGTH returns string length"],"correctIndex":0}
{"prompt":"Hard 96 (procedures + lists): This procedure returns the last index. What is the bug?","code":"PROCEDURE lastIndex(list) {\n  RETURN(LENGTH(list) - 1)\n}","choices":["AP CSP lists end at LENGTH(list), not LENGTH(list) - 1","It should return 0","LENGTH is invalid","RETURN must be in a loop"],"correctIndex":0}
{"prompt":"Hard 97 (procedures + lists): This procedure builds a list of squares. What is the bug?","code":"PROCEDURE squareList(list) {\n  FOR EACH n IN list {\n    n ← n * n\n  }\n  RETURN(list)\n}","choices":["Loop variable n is a copy of the value; updating it doesn't change the list","n should be index","RETURN must be inside loop","List cannot be returned"],"correctIndex":0}
{"prompt":"Hard 98 (procedures + lists): This procedure counts negatives. Why is the count 0?","code":"PROCEDURE countNeg(list) {\n  c ← 0\n  FOR EACH n IN list {\n    IF (n < 0) {\n      c ← c * 1\n    }\n  }\n  RETURN(c)\n}","choices":["It multiplies c by 1 instead of adding 1, so c remains 0","c should start at 1","The condition should be n > 0","RETURN c inside loop"],"correctIndex":0}
{"prompt":"Hard 99 (procedures + lists): This procedure should append matching elements. Why is it empty?","code":"PROCEDURE matches(list, val) {\n  res ← []\n  FOR EACH n IN list {\n    IF (n ≠ val) {\n      APPEND(res, n)\n    }\n  }\n  RETURN(res)\n}","choices":["It collects non-matching elements instead of matching ones","res should be list","APPEND should be REMOVE","The loop is wrong"],"correctIndex":0}
{"prompt":"Hard 100 (procedures + lists): This procedure sums a list. Why is the sum 0?","code":"PROCEDURE summation(list) {\n  total ← 0\n  FOR EACH n IN list {\n    total ← n\n  }\n  RETURN(total)\n}","choices":["It overwrites total with n each time instead of adding to it","total should start at 1","n should be index","RETURN total inside loop"],"correctIndex":0}